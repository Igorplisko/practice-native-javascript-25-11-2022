

--Отличий между обычными и стрелочными функциями:
1. this
1.1 Обыкновенные функции
Внутри обыкновенной функции значение this динамическое(в зависимости от контекста исполнения).Динамический контекст означает, что значение this зависит от того как была вызвана функция. 
1.2 Стрелочные функции(Отсутствие связывания с this)
Поведение this внутри стрелочной функции отличается от поведения this внутри обычной функции.Не имеет значения как она была вызвана, значение this внутри стрелочной функции всегда эквивалентно значения this внешней функции

2.Вызов с помощью call или apply
Так как значение this определяется лексикой, вызов стрелочных функций с помощью методов call() или apply(), даже если передать аргументы в эти методы, не влияет на значение this.

3. Не имеет собственного объекта arguments
Стрелочные функции не имеют собственного объекта arguments, поэтому в теле стрелочных функций arguments будет ссылаться на переменную в окружающей области.

4. Стрелочные функции
Как следствие того, что стрелочные функции не имеют собственного this они не могут быть использованы для создания объектов.Если ты попытаешься вызвать стрелочную функцию с использованием ключевого слова new, JS кинет исключение:

5.У стрелочных функций нет доступа к объекту arguments.
5.1 Обыкновенные функции
Внутри тела обыкновенной функции, существует специальный массив arguments содержащий список аргументов с которым функция была вызвана.
5.2 Стрелочные функции
С другой стороны, в стрелочных функциях отсутствует специальное слово arguments.Опять, точно так же, как и со значение this массив arguments для стрелочных функций будет браться из внешней функции.
объявленного с помощью const, но не само свойство (переменную).

6.Мы также можем передавать параметры стрелочным функциям.Если мы передаем один параметр, его можно не оборачивать в круглые скобки и можем не писать return.

//?--------------------------------------------------------------------------------------------------------

--В чем разница между ключевыми словами «var », «let» и «const »?

   Переменные, объявленные с помощью ключевого слова «var », являются глобальными.Это означает, что они доступны из любого места в коде.
      Результатом первого console.log является undefined, поскольку объявленные переменные, которым не присвоено значения, имеют значение undefined по умолчанию.


      Переменные, объявленные с помощью ключевых слов «let» и «const » имеют блочную область видимости.Это означает, что они доступны только внутри блока ({})
Разница между «let» и «const » состоит в том, что в первом случае мы может менять значение переменной, а во втором —
   нет (константа).При этом, мы можем менять значение свойства объекта, объявленного с помощью const, но не само свойство (переменную).
//?--------------------------------------------------------------------------------------------------------

--В чем разница между spread - оператором и rest - оператором ?
   Операторы spread и rest имеют одинаковый синтаксис("...").Разница состоит в том, что с помощью spread мы передаем или распространяем данные массива на другие данные, а с помощью rest — получаем все параметры функции и помещаем их в массив(или извлекаем часть параметров).
//?--------------------------------------------------------------------------------------------------------



 --Как записать несколько выражений в одну строку ?
   Для этого мы можем использовать оператор ","(запятая).Этот оператор «двигается» слева направо и возвращает значение последнего выражения или операнда.
let x = 5
x = (x++, x = addFive(x), x *= 2, x -= 5, x += 10)
//?--------------------------------------------------------------------------------------------------------


--1. Как проверить, является ли значение ложным ?
   Следует использовать функцию Boolean или оператор "!!"(двойное отрицание).
//?--------------------------------------------------------------------------------------------------------

   2. Для чего используется оператор "!!" ?
   Оператор "!!"(двойное отрицание) приводит значение справа от него к логическому значению.
      console.log(!!null) // false
console.log(!!undefined) // false
console.log(!!'') // false
console.log(!!0) // false
console.log(!!NaN) // false
console.log(!!' ') // true
console.log(!!{}) // true
console.log(!![]) // true
console.log(!!1) // true
console.log(!![].length) // false
//?--------------------------------------------------------------------------------------------------------

--3. Какие значения в JS являются ложными ?

const falsyValues = [' ', 0, null, undefined, NaN, false]

Ложными являются значения, результатом преобразования которых в логическое значение является false.
//?--------------------------------------------------------------------------------------------------------


--4. JavaScript определяет 7 типов: данных:
null
undefined
boolean
string
number
object
symbol(добавлен в ES6)
//?--------------------------------------------------------------------------------------------------------

--5. У стрелочных функций есть два основных преимущества перед традиционными функциями.Первое — это очень удобный и компактный синтаксис.Второе заключается в том, что подход к работе со значением this в стрелочных функциях выглядит интуитивно понятнее, чем в обычных функциях.
//?--------------------------------------------------------------------------------------------------------


--6.Что такое поднятие(Hoisting) ?
   Поднятие — это термин, описывающий подъем переменной или функции в глобальную или функциональную области видимости.
   //?--------------------------------------------------------------------------------------------------------

  
  
 --5. Для чего используется директива «use strict» ?
«use strict» — это директива ES5, которая заставляет весь наш код или код отдельной функции выполняться в строгом режиме.Строгий режим вводит некоторые ограничения по написанию кода, тем самым позволяя избегать ошибок на ранних этапах.
  //?--------------------------------------------------------------------------------------------------------



--6. Что такое IIFE ?
   IIFE или Immediately Invoked Function Expression — это функция, которая вызывается или выполняется сразу же после создания или объявления.Для создания IIFE необходимо обернуть функцию в круглые скобки(оператор группировки), превратив ее в выражение, и затем вызвать ее с помощью еще одних круглых скобок.Это выглядит так: (function () { })().
     //?--------------------------------------------------------------------------------------------------------



--7. Что такое промисы(Promises) ?
   Промисы — это один из приемов работы с асинхронным кодом в JS.Они возвращают результат асинхронной операции.Промисы были придуманы для решения проблемы так называемого «ада функций обратного вызова».
//?--------------------------------------------------------------------------------------------------------


--8.Какие приемы работы с асинхронным кодом в JS Вы знаете ?

   1.1 Функции обратного вызова(Callbacks).
1.2 Промисы(Promises).
1.3 Async / await.
1.4 Библиотеки вроде async.js, blueprint, q, co.
//?--------------------------------------------------------------------------------------------------------



--8. В чем разница между операторами "==" и "===" ?
   Разница между оператором "=="(абстрактное или нестрогое равенство) и оператором "==="(строгое равенство) состоит в том, что первый сравнивает значения после их преобразования или приведения к одному типу(Coersion), а второй — без такого преобразования.
      Операторы === и !== являются операторами строгого сравнения.Значит, если операнды имеют разные типы, то не являются равными.Например:

1 === "1" // возвращает false
1 !== "1"  // возвращает true
null === undefined // возвращает false
Операторы == и != являются операторами, скажем, грубого сравнения.То есть, если операнды имеют разные типы, JavaScript пытается как - то преобразовать их, чтобы стали сравнимыми.Например:

1 == "1" // возвращает true
1 != "1" // возвращает false
null == undefined // возвращает true
Интересно заметить, что в отличие от ===, оператор == не является транзитивным:

"0" == 0 // true
0 == ""  // true
"0" == ""// false
Не очень легко помнить правила этого грубого сравнения, и иногда бывает, что оно работает неожиданным образом.Поэтому, я рекомендую использовать === вместо ==.
//?--------------------------------------------------------------------------------------------------------










//!------------------------------------------------------------------------------------------------------------------------
--1.В чем разница между null и undefined ?
   Они являются ложными значениями, т.е.результатом их преобразования в логическое значение с помощью Boolean() или оператора "!!" является false:
console.log(!!null) // false
console.log(!!undefined) // false
console.log(Boolean(null)) // false
console.log(Boolean(undefined)) // false

undefined(«неопределенный») представляет собой значение по умолчанию:
--переменной, которой не было присвоено значения, т.е.объявленной, но не инициализированной переменной;
--функции, которая ничего не возвращает явно, например, console.log(1);
--несуществующего свойства объекта.

В указанных случаях движок JS присваивает значение undefine:
let _thisIsUndefined
const doNothing = () => { }
const someObj = {
   a: 'ay',
   b: 'bee',
   c: 'si'
}
console.log(_thisIsUndefined) // undefined
console.log(doNothing()) // undefined
console.log(someObj['d']) // undefined

null — это «значение отсутствия значения».null — это значение, которое присваивается переменной явно.В примере ниже мы получаем null, когда метод fs.readFile отрабатывает без ошибок:

fs.readFile('path/to/file', (e, data) => {
   console.log(e) // здесь мы получаем null
   if (e) {
      console.log(e)
   }
   console.log(data)
})

При сравнении null и undefined мы получаем true, когда используем оператор "==", и false при использовании оператора "===".О том, почему так происходит, см.ниже.

   console.log(null == undefined) // true
console.log(null === undefined) // false

//!------------------------------------------------------------------------------------------------------


--2.Что такое область видимости(Scope) ?

   Область видимости — это место, где(или откуда) мы имеем доступ к переменным или функциям.JS имеем три типа областей видимости: глобальная, функциональная и блочная(ES6).

Глобальная область видимости — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и доступны из любого места в коде.

// глобальное пространство имен
var g = 'global'

function globalFunc() {
   function innerFunc() {
      console.log(g) // имеет доступ к переменной g, поскольку она является глобальной
   }
   innerFunc()
}

Функциональная область видимости(область видимости функции) — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции.

function myFavouriteFunc(a) {
   if (true) {
      var b = 'Hello ' + a
   }
   return b
}
myFavouriteFunc('World')

console.log(a) // Uncaught ReferenceError: a is not defined
console.log(b) // не выполнится

Блочная область видимости — переменные(объявленные с помощью ключевых слов «let» и «const ») внутри блока ({}), доступны только внутри него.

function testBlock() {
   if (true) {
      let z = 5
   }
   return z
}

testBlock() // Uncaught ReferenceError: z is not defined

//!------------------------------------------------------------------------------------------------------


//!В чем разница между spread-оператором и rest-оператором?
Операторы spread и rest имеют одинаковый синтаксис("...").Разница состоит в том, что с помощью spread мы передаем или распространяем данные массива на другие данные, а с помощью rest — получаем все параметры функции и помещаем их в массив(или извлекаем часть параметров).

function add(a, b) {
   return a + b
}

const nums = [5, 6]
const sum = add(...nums)
console.log(sum) // 11

В этом примере мы используем spread при вызове функции add с данными массива nums.Значением переменной «a» будет 5, b = 6, sum = 11.

function add(...rest) {
   return rest.reduce((total, current) => total + current)
}

console.log(add(1, 2)) // 3
console.log(add(1, 2, 3, 4, 5)) // 15

Здесь мы вызываем функцию add с любым количеством аргументов.Add возвращает сумму этих аргументов.

   const[first, ...others] =[1, 2, 3, 4, 5]
console.log(first) // 1
console.log(others) // [2, 3, 4, 5]

В этом примере мы используем rest для помещения любого количества параметров, кроме первого, в массив others.
//!------------------------------------------------------------------------------------------------------